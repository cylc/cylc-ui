<!--
Copyright (C) NIWA & British Crown (Met Office) & Contributors.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->

<template>
  <div>
    <div ref="main-wrapper" id="main-wrapper" class="pa-4 fill-height"></div>
    <div v-show="false">
      <tree-wrapper
          v-for="widgetId of this.treeWidgetIds"
          :key="widgetId"
          :workflows="workflows"
          :widgetId="widgetId"
          :is-loading="workflowTree === null || workflowTree.root.id === ''"
      />
      <graph-wrapper
          v-for="widgetId of this.graphWidgetIds"
          :key="widgetId"
          :workflow-name="workflowName"
          :widgetId="widgetId"
          :is-loading="isLoading"
      />
      <mutations-wrapper
          v-for="widgetId of this.mutationsWidgetIds"
          :key="widgetId"
          :workflow-name="workflowName"
          :widgetId="widgetId"
          :is-loading="isLoading"
      />
    </div>
  </div>
</template>

<script>
import { BoxPanel, DockPanel, Widget } from '@lumino/widgets'
import { each, iter } from '@lumino/algorithm'
import {
  ContentWidget,
  GraphWrapper,
  TreeWrapper,
  MutationsWrapper
} from '@/components/cylc/workflow/index'

export default {
  name: 'Workflow',
  props: {
    workflowTree: {
      type: Object
    },
    workflowName: {
      type: String,
      required: true
    },
    isLoading: {
      type: Boolean,
      default: false
    }
  },
  components: {
    // TODO: once our components (tree, graph, dot, etc) share a common interface (i.e. same props) we should be able to have a single wrapper
    'tree-wrapper': TreeWrapper,
    'graph-wrapper': GraphWrapper,
    'mutations-wrapper': MutationsWrapper
  },
  data () {
    return {
      // create a box panel, which holds the dock panel, and controls its layout
      main: new BoxPanel({ direction: 'left-to-right', spacing: 0 }),
      // create dock panel, which holds the widgets
      dock: new DockPanel(),
      treeWidgetIds: [],
      graphWidgetIds: [],
      mutationsWidgetIds: []
    }
  },
  computed: {
    workflows () {
      if (!this.workflowTree) {
        return []
      }
      return this.workflowTree.root.children
    }
  },
  created () {
    this.dock.id = 'dock'
    this.main.id = 'main'
    this.main.addWidget(this.dock)
    window.onresize = () => { this.main.update() }
    BoxPanel.setStretch(this.dock, 1)
    const vm = this
    this.$nextTick(() => {
      Widget.attach(vm.main, vm.$refs['main-wrapper'])
    })
  },
  methods: {
    addTreeWidget (id) {
      const contentWidget = new ContentWidget(id, 'tree')
      this.dock.addWidget(contentWidget)
      this.treeWidgetIds.push(id)
    },
    addGraphWidget (id) {
      const contentWidget = new ContentWidget(id, 'graph')
      this.dock.addWidget(contentWidget)
      this.graphWidgetIds.push(id)
    },
    addMutationsWidget (id) {
      const contentWidget = new ContentWidget(id, 'mutations')
      this.dock.addWidget(contentWidget)
      this.mutationsWidgetIds.push(id)
    },
    removeAllWidgets () {
      const dockWidgets = this.dock.widgets()
      const widgets = []
      each(iter(dockWidgets), widget => {
        widgets.push(widget)
      })
      widgets.forEach(widget => widget.close())
    },
    removeTreeWidget (id) {
      const index = this.treeWidgetIds.indexOf(id)
      if (index > -1) {
        this.treeWidgetIds.splice(index, 1)
      }
    },
    removeGraphWidget (id) {
      const index = this.graphWidgetIds.indexOf(id)
      if (index > -1) {
        this.graphWidgetIds.splice(index, 1)
      }
    }
  }
}
</script>
